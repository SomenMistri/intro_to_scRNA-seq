---
title: "R Notebook - 2_data_integration_and_clustering"
output: html_notebook
---
#### Some useful links
https://satijalab.org/seurat/articles/pbmc3k_tutorial.html
https://satijalab.org/seurat/articles/merge_vignette.html
https://satijalab.org/seurat/articles/integration_introduction.html
https://satijalab.org/seurat/articles/sctransform_vignette.html

#### Get the input file
In the "1_Data_loading_and_QC_filtering" folder, you will find the "data_filtered.rds" file. Copy that file to the current folder where you have the .rmd file ("2_Integration_and_Clustering")

#### Load required packages
To load the required packages using the library() function, run chunk 1 by clicking on the "Run Current Chunk" button on the right. This will load the following packages.

```{r chunk 1}
library(XVector)
library(Seurat)
library(tidyverse)
library(Matrix)
library(RCurl)
library(scales)
library(sctransform)
```
Note: If you have not installed the packages yet, then install them first before loading

#### Load the filtered seurat object (data_filtered.rds) 
Read in the filtered data by running chunk 2. The readRDS() function used in this chunk can read in R objects that were previously created.

```{r chunk 2}
data.filtered <- readRDS ("data_filtered.rds")

#Let's take a look at the data to make sure everything looks good
head(data.filtered)
```

#### Normalization with SCTransform() function
Run chunk 3 to normalize the filtered cells (data.filtered) using the SCTransform() function of seurat.
```{r chunk 3}
# perform SCTransform normalization
data_SCT <- SCTransform(data.filtered, verbose = TRUE) 
```

#### Perform PCA
Now perform principal component analysis (PCA) on the normalized (using the SCTranform function) dataset by running chunk 4
```{r chunk 4}
data_PCA<- RunPCA(data_SCT, npcs = 40, verbose = FALSE)
```

#### Identify significant PCs
To overcome the extensive technical noise in the expression of any single gene for scRNA-seq data, Seurat assigns cells to clusters based on their PCA scores derived from the expression of the integrated most variable genes, with each PC essentially representing a “metagene” that combines information across a correlated gene set. Determining how many PCs to include in the clustering step is therefore important to ensure that we are capturing the majority of the variation, or cell types, present in our dataset.

It is useful to explore the PCs prior to deciding which PCs to include for the downstream clustering analysis.

One way of exploring the PCs is using a heatmap to visualize the most variant genes for select PCs with the genes and cells ordered by PCA scores. The idea here is to look at the PCs and determine whether the genes driving them make sense for differentiating the different cell types.

The elbow plot is another helpful way to determine how many PCs to use for clustering so that we are capturing majority of the variation in the data. The elbow plot visualizes the standard deviation of each PC, and we are looking for where the standard deviations begins to plateau. Essentially, where the elbow appears is usually the threshold for identifying the majority of the variation. However, this method can be quite subjective.

Run chunk 5 to create both the heatmap and elbow plot.

```{r chunk 5}
# Explore heatmap of PCs
DimHeatmap(data_PCA, 
           dims = 1:10, 
           cells = 500, 
           balanced = TRUE)
# Let's draw the elbow plot using the top 40 PCs
ElbowPlot(object = data_PCA, 
          ndims = 40)
```

#### Cluster the cells
Clusters of cells are obtained by grouping cells based on the similarity of their gene expression profiles. Expression profile similarity is determined via distance metrics, which often take dimensionality‐reduced representations as input. Seurat assigns cells to clusters based on their PCA scores derived from the expression of the integrated most variable genes.

While PCA determines all PCs, we can only plot two at a time. In contrast, dimensionality reduction techniques such as Uniform Manifold Approximation and Projection (UMAP) take the information from any number of top PCs to arrange the cells in this multidimensional space. It takes those distances in multidimensional space and plot them in two dimensions working to preserve local and global structure. In this way, the distances between cells represent similarity in expression.

For clustering the cells, Seurat uses a graph-based clustering approach using a K-nearest neighbor approach, and then attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’. The first step is to construct a K-nearest neighbor (KNN) graph based on the euclidean distance in PCA space. This is done in Seurat by using the FindNeighbors() function. Next, Seurat iteratively groups cells together with the goal of optimizing the standard modularity function. The FindClusters() function of Seurat takes care of this graph-based clustering. The resolution is an important argument at this step that sets the “granularity” of the downstream clustering and will need to be optimized for every individual experiment. For datasets of 3,000 - 5,000 cells, the resolution set between 0.4-1.4 generally yields good clustering. Increased resolution values lead to a greater number of clusters, which is often required for larger datasets.

Note: The RunUMAP() and FindNeighbors() functions will require you to input number of PCA dimentions to use for the visualization. It is suggested to use the same number of PCs as input in both cases.

Run chunk 6 to perform RunUMAP(), FindNeighbors(), FindClusters() functions one after another:

```{r chunk 6}
# Runs the Uniform Manifold Approximation and Projection (UMAP) dimensional reduction technique
data_clust <- RunUMAP(data_PCA, reduction = "pca", dims = 1:30)
# Determine the K-nearest neighbor graph
data_clust <- FindNeighbors(object = data_clust, 
                                dims = 1:30)
# Perform graph based clustering
data_clust <- FindClusters(object = data_clust,
                               resolution = 0.6)

# Visualize clustered cells
DimPlot(data_clust, reduction = "umap", label = TRUE) + NoLegend()

# Save the clustered plot
ggsave(path = "Figs", filename = "Clusters.png",  height=5, width=6, units='in', dpi = 300, bg = "transparent", device='png')
```

#### Explore metadata to check whether "seurat_clusters" column was added or not
Run chunk 7 to quickly check whether "seurat_clusters" column was added to the metadata or not.

```{r chunk 7}
head(data_clust@meta.data)
```

### Explore sources of unwanted variation

The first step in the workflow is to see if our data contains any unwanted variability. The most common biological effect that is evaluated in single-cell RNA-seq data is the effect of cell cycle on the transcriptome. Another unwanted variability can be caused by batch effect which is a technical source of variation. This step of the workflow involves exploring our data to identify which covariates we would like to correct for.

Run chunk 8 to Explore the effects of cell cycle genes:
```{r chunk 8}
# Evaluating effects of cell cycle (Phase)
DimPlot(data_clust, group.by = "Phase", label = FALSE)

# Save the plot
ggsave(path = "Figs", filename = "CellCycle_Phase.png",  height=5, width=7, units='in', dpi = 300, bg = "transparent", device='png')
```
Run chunk 9 to explore technical sources of variation such as the Batch Effect:
```{r chunk 9}
# Set identity classes to seurat_clusters
Idents(object = data_clust) <- "seurat_clusters"

# Explore the significance of back effect on clustering
DimPlot(data_clust, split.by = "orig.ident", label = TRUE, ncol = 2)+ NoLegend()

# Save the plot
ggsave(path = "Figs", filename = "Batch_effect.png",  height=6, width=8, units='in', dpi = 300, bg = "transparent", device='png')
```

Run chunk 10 to save the SCTransformed and clustered RDS file 
```{r chunk 10 }
saveRDS(data_clust, file= "data_clust_no_integration.rds") 
```

#### data integration 
Run chunk 11 to perform the integration in one click. 

First, split the filtered seurat object to individual human samples and perfrom SCtransform on each sample separately. At this step, we can regress out any sources of variation such as cell cycle features, percent.MT, percent.RIBO etc. Here, we will regress out variations caused by cell cycle genes (S.Score,G2M.Score) (Note: This particular dataset does not require cell cycle regression. However, we will perform the regression anyway to practice.

Following SCTransform normalization, we will perform integration of data using the following seurat function one after another: SelectIntegrationFeatures(), PrepSCTIntegration(), FindIntegrationAnchors(), and IntegrateData()

```{r chunk 11}
#Let's split the object based on orig.ident
Idents(data.filtered) <- "orig.ident"
data.list <- SplitObject(data.filtered, split.by = "ident")

# perform SCTransform normalization with cell cycle regression
data.list <- lapply(X = data.list, FUN = function(x) {
    x <- SCTransform(x, vars.to.regress = c("S.Score","G2M.Score"), verbose = FALSE)
})

# select integration features and prep step
features <- SelectIntegrationFeatures(data.list)
data.list <- PrepSCTIntegration(
  data.list,
  anchor.features = features
)

# downstream integration steps
anchors <- FindIntegrationAnchors(
  data.list,
  normalization.method = "SCT",
  anchor.features = features
)
data.integrated <- IntegrateData(anchors, normalization.method = "SCT")

#Save the integrated file
saveRDS(data.integrated, "data.integrated.rds")
```


### Cluster the cells of integrated dataset

To perform PCA and identify significant PCs in the integrated data, please run the chunk 12:
```{r chunk 12}
data_PCA2<- RunPCA(data.integrated, npcs = 40, verbose = FALSE)

# Explore heatmap of PCs
DimHeatmap(data_PCA2, 
           dims = 1:10, 
           cells = 500, 
           balanced = TRUE)

# Plot the elbow plot
ElbowPlot(object = data_PCA2, 
          ndims = 40)
```

Run chunk 13 to perform RunUMAP(), FindNeighbors(), FindClusters() functions one after another on the integrated dataset:

```{r chunk 13}
# Runs the Uniform Manifold Approximation and Projection (UMAP) dimensional reduction technique
data_clust2 <- RunUMAP(data_PCA2, reduction = "pca", dims = 1:30)
# Determine the K-nearest neighbor graph
data_clust2 <- FindNeighbors(object = data_clust2, 
                                dims = 1:30)
# Perform graph based clustering
data_clust2 <- FindClusters(object = data_clust2,
                               resolution = 0.4)

# Visualize clustered cells
DimPlot(data_clust2, reduction = "umap", label = TRUE) + NoLegend()

# Save the clustered plot
ggsave(path = "Figs", filename = "Clusters_integrated.png",  height=5, width=6, units='in', dpi = 300, bg = "transparent", device='png')
```
Explore technical sources of variation such as the Batch Effect on integrated data by running chunk 14:
```{r chunk 14}
# Set identity classes to seurat_clusters
Idents(object = data_clust2) <- "seurat_clusters"

# Explore the significance of back effect on clustering
DimPlot(data_clust2, split.by = "orig.ident", label = TRUE, ncol = 2)+ NoLegend()

# Save the plot
ggsave(path = "Figs", filename = "Batch_effect_integrated.png",  height=6, width=8, units='in', dpi = 300, bg = "transparent", device='png')
```

### Save the integrated and clustered cells

Run chunk 15 to save the integrated and clustered cells as a RDS file 

(Note: this file is important for the next lesson)
```{r chunk 15}
saveRDS(data_clust2, file= "data_clust_integrated.rds") 
```

------End------